module T_

  (module DExport,  -- so, after Test is loaded, all the DoCon
                    -- export is accessible from Test
   test, 
   t_permut_,
   primesBySieve, t_primes_,   
   t_rse_,   
   t_polarit_,  
   t_finfield_,  
   t_rpol_,  
   t_demo1_, 
   t_diagmatr_,  
   pControlSum, t_grbas1_, 
   t_grbas2_,  
   t_cubeext_,
   t_sphGeo_, 
   t_symfunc_,  
   t_detinterp_,
   pFactorizControlSum, testFFPolFactrz, t_pfactor1_, 
   t_pfactor2_, testFactorBi
  )

where
import Prelude hiding (minimum, maximum)
import Data.Maybe (isJust)

import DExport 
import T_permut    (t_permut_                )
import T_primes    (primesBySieve, t_primes_ )
import T_reseuc    (t_rse_                   )
import T_polArit   (t_polarit_               ) 
import T_finfield  (t_finfield_              ) 
import T_rpol      (t_rpol_                  ) 
import T_demo1     (t_demo1_                 )
import T_diagmatr  (t_diagmatr_              )
import T_grbas1    (pControlSum, t_grbas1_   )
import T_grbas2    (t_grbas2_                )
import T_cubeext   (t_cubeext_               )
import T_sphGeo    (t_sphGeo_                )
import T_symfunc   (t_symfunc_               )
import T_detinterp (t_detinterp_             )

import T_pfactor  (pFactorizControlSum, testFFPolFactrz,
                   t_pfactor1_, t_pfactor2_, testFactorBi)



------------------------------------------------------------------------
header = ("===============\n"++)
finsep = ("--- RESULT: \n"++)

test path =   -- the result prints to standard output 
  let         -- and duplicates in the given file `path'
    hd = 
     "\n\nDoCon-2.12   T E S T   for mathematical computation\n\n\
     \Each part of the test produces a message ending with the line \
     \of kind\n[True,True ...].\n\
     \If it appears any  False  or the program breaks, then here the \
     \error\nlocates.\n\n\
     \The output is COPIED to the FILE given in the argument. Say,\n\
     \ test \"log\"   creates a copy in the file  ./log\n\
     \source/demotest/T_*.hs  show precisely the chosen examples.\n\
     \Also T_*.hs show how to run them for  Demo and Benchmark.\n\n\
     \The simpler examples requiring less of DoCon functionality run \
     \first,\nthen run the more complex ones.\n\n\
     \PRESS  ENTER  to start.\n\n"

    (ok, f) = tt
    msg'    = if ok then "*** NO errors detected ***\n\n"
              else         
              "*** ERROR ***\n\nLook for the occurrences of  False\n\
              \in the above messages to locate the errors.\n"

    msg1 = f ("\n\n*** Test FINISHED ***\n\n" ++ msg')
  in
  putStr hd >> writeFile path hd >> getChar >> putStr msg1 >> 
  appendFile path msg1 





------------------------------------------------------------------------
-- This function chooses examples and applies to them more generic
-- functions generated by the tests from the modules T_* 

tt = (ok, f)
  where
  f = 
    permut'            . primes'             . rse'                 .
    polArithm1'        . polArithm2'         . rpol'                . 
    finField1'         . finField2'          . demo1'               . 
    diagmatr'          . gbasCone'           . gbasBu12'            .
    gbasCst'           . gbasCyclRoot'       . gbasMoe12'           . 
    gbasOverP'         . syzAl'              . syzCocoa'            . 
    cyclicInt5'        . cubeext'            . sphGeo'              .
    charKostka'        . discrSym'           . symMonToE'           .
    upolInterp1'       . upolInterp2'        . factor1overPrimeFin' .
    factor1overGenFin' . factor2overPrimeFin'

  ok = and $ ((concat permut)             ++) $
             (primesT                     ++) $
             (rse                         ++) $
             (polArithm                   ++) $
             ((tuple31 t_rpol_)           ++) $
             (finField                    ++) $
             ((take 2 $ tuple31 t_demo1_) ++) $
             ((fst t_diagmatr_)           ++) $
             ((fst gbasCone)              ++) $
             ((fst gbasBu1 )              ++) $
             ((fst gbasBu2 )              ++) $
             ((fst gbasCst)               ++) $
             ((fst gbasCyclRoot)          ++) $
             ((fst gbasMoe1)              ++) $
             ((fst gbasMoe2)              ++) $
             ((fst gbasOverP)             ++) $
             ((tuple51 al)                ++) $
             ((tuple51 cocoa)             : ) $
             ((tuple31 cyclicInt5)        ++) $
             ((tuple41 t_cubeext_)        ++) $
             ((tuple31 t_sphGeo_ )        ++) $
             ((concat charKostkaTest)     ++) $
             ((concat discrSymTest)       ++) $
             (symMonToETest               ++) $
             (((fst interp):(snd interp)) ++) $
             (factor1overPrimeFin         ++) $
             (factor1overGenericFin       ++) 
             factor2overPrimeFin         

  permut  = map (fst . t_permut_) [1 .. nN]  where nN = 7 -- old: 6
  primesT = let ((s, s'), (t, t'), _) = t_primes_  in  [s, t]  
                                               -- s',t' may be expensive

  rse = let (t, t', psTest, sumRs) = t_rse_  in  [t, psTest]
                                                  -- t' may be expensive
  polArithm = 
          let ((fromH, cspps), gcds, powBench, gcdBench, _) = t_polarit_ 
              gcds' = map and $ map fst gcds
          in  [fromH, cspps, and gcds']

  finField = tuple41 t_finfield_
  [gbasCone, gbasBu1, gbasBu2, gbasCst, gbasArL, gbasCyclRoot] =
                                                       tuple31 t_grbas1_
  (gbasMoe1, gbasMoe2, gbasOverP) = tuple32 t_grbas1_

  (al, cocoa, _, cyclicInt) = t_grbas2_    -- abya  skipped here
  cyclicInt5                = cyclicInt 5
  (charKostka, discrSym, symMonToE) = t_symfunc_
  charKostkaTest = map (tuple41 . charKostka) [1 .. 9]  -- old: 8
  discrSymTest   = 
          map tuple31 [discrSym "mn" 3, discrSym "m" 3, discrSym "mn" 4]

  symMonToETest = map tuple41 
                   [symMonToE "mn" 3, symMonToE "m" 3, symMonToE "mn" 4]
  interp = (intr, dIntr)
           where
           q    = 11
           sf1  = "(t+1)*x^2 + t^2*x + 2" 
           sg1  = "t*x^2 + 3*x^3 + t" 
           sf2  = "(t^2+1)*x^4 + 3*x^3 + t^2*x^2 + t^3 +t + 2" 
           sg2  = "x^4 - (t+1)*x^3 + t^2*x " 
           fsts = map tuple51 $ 
                      zipWith (t_detinterp_ q) [sf1, sf2] [sg1, sg2]

           intr = head $ head fsts   -- direct interpolation test 
                                     -- for several polynomials in t
           dIntr = map last fsts     -- finding resultants in two ways

  factor1overPrimeFin = [f1Test, knuTest,  testp 2 t2 6, testp 3 t3 4]
        where
        tfs@[tf2,tf3,tf5,tf13,tf17] = map t_pfactor1_ [2,3,5,13,17]
                                                             -- old: 13
        ts@ [t2,  t3 , t5,  t13,  t17 ] = map tuple43 tfs
        [    op2, op3, op5, op13, op17] = map tuple41 tfs
        (f1Test:_,    _) = op5
        (_:knuTest:_, _) = op13
        testp q t n =
          and [testFFPolFactrz d (factor (t^(q^d) - t)) | d <- [1 .. n]]

  factor1overGenericFin = let (_, _, t, og) = t_pfactor1_ 5
                              i2            = fromi t 2
                          in  tuple31 $ og (t^3-t-i2)

  factor2overPrimeFin = concat [biTest, family1test (p1, y+p1),
                                family1test (p1, y+p2)]
      where
      (unP, family1, _) = t_pfactor2_ 5 
      y                 = smParse unP "y"
      [p0, p1, p2]      = map (fromi unP) [0 .. 2]
      [fS, gS] = ["x^3 + y*(x + 1)", "x^3 + y*(y*x^2 + 2)"]
      biTest = [fst (testFactorBi p1 fS gS i j) | 
                (i, j) <- [(0,1), (1,0), (1,1), (1,2), (2,1)]
               ]
      m                  = 2
      family1test (b, p) = 
                 [not $ isJust $ fst $ family1 b p n m | n <- [3, 4, 5]]
                                                               -- old: 4
  ----------------------------------------------------------------------
  permut' =
    showString (concat
     ["\n\nPermutation group S = S(n)\n", header "",
      "List all permutations p from S and test each p as follows\n\
      \cG     = cyclicGroup(p)  in S(n).\n\
      \cycles = [cl(1)..cl(k)] = decomposition of p to cycles.\n\
      \Verify\n\
      \  0 < card cG <= card S,\n\
      \  cG is free of repetitions and contains unity,\n\
      \  composition of cycles   == p,\n\
      \  lcM (map length cycles) == card cG.\n\
      \And for  n,  test  osetCard S == n!\n\
      \Do this all for  n <- [1..nN].   Here  nN = 7.\n"
     ]) .
    finsep . shows permut 

  primes' = showString "\n\nInteger factorization and List of primes \
                                           \test - sieve and other.\n" .
            finsep . shows primesT 

  rse' = showString "\n\nProperties and division in a residue ring  \
                    \Z/(b)\n  modelled as  ResidueE Integer:\n" . 
         finsep . shows rse 

  polArithm1' =
     showString "\n\nArithmetic in  P = Z[z,y,x]  and in  Z[x][y][z].\n\
                \The isomorphism test for these domains:  verify\n\
                \(^n) == fromP . (^n) . toP\n" .
     finsep . shows (init polArithm) 

  polArithm2' =
    showString (concat
     ["\n\nGCD in P.\n", header "",
      "For  d,f,g,  find  f' = d*f, g' = d*g,  h = gcd f' g' and \
      \verify that\nh  divides f' and g',  and that  f'/h, g'/g  are \
      \reciprocally\nprime. There are chosen\n\
      \  d = (2*z + 3*y + 4*x)*(z*y*x^2 + y^3 + 1),\n\
      \  f = (z + y + x)^m,\n\
      \  g = (z - y + x + 2)^m,  m = 1,2,3.\n"
     ]) .
     finsep . shows (last polArithm) 

  rpol' = showString "\n\nR-polynomials. Set of variables, conversion \
                     \ Pol--RPol,\n\
                     \testing  (^2) == fromRPol . (^2) . toRPol:\n" .
          finsep . shows (tuple31 t_rpol_) 

  finField1' =
        showString 
            "\n\nArithmetic of finite field  F = F25 = Z5[x]/(x^2+2).\n\
            \Full division test;  x^8 == 1;\n\
            \generating the full multiplicative group with  2x + 3.\n" . 
        finsep . shows (init finField) 

  finField2' = showString "\n\nGCD in F25[v,w]. gcd (v*(v^5+1)) \
                                            \(w*(v+1)^2) = (v+1)^2.\n" .
               finsep . shows (last finField) 
  demo1' = showString 
             "\n\nSolving Linear System M*x = 0  for a matrix over Z,\n\
             \Inversion of a matrix M' over Rational and verifying\n\
             \(M'*inv(M') == unityMatrix.\n\
             \M, M' are chosen of the sizes 3 by 6, 6 by 6.\n" . 
           finsep . shows (take 2 $ tuple31 t_demo1_)

  diagmatr' =
    showString 
       "\n\nDiagonalization of a matrix M over K[x], K a field.\n\
       \Applying generalized Gauss method,  find such invertible T, U \
       \ that\nT*M*U = D  is a diagonal matrix.\n\
       \Then, check the above equality and that  det(D) = +-det(M).\n\
       \M is chosen of size 3 by 3.   Here we choose K = Z/(p).\n" .
    finsep . shows (fst t_diagmatr_) 

  gbasCone' =
    showString (concat 
        ["\n\nGroebner basis over a field K.\n", header "\n",
         "Deriving the cone equation in  K^3  from the polynomial \
         \parameterization\nfs = [x(u,v), y(u,v), z(u,v)].\n\
         \Find  gs = GroebnerBasis(fs)  respectively to the lex \
         \ ordering for\n[u,v,x,y,z].  (head gs) is the required \
         \equation.\ngxBasis_test  is also applied that\n\
         \ finds gs' = Groebner basis gs,\n\
         \ tests the reduction of  fs by gs, gs' by gs, gs by gs',\n\
         \ tests the transformation matrix fs -> gs.\n"
        ]) .
    finsep . shows (fst gbasCone) 

  gbasBu12' = showString "\n\nGroebner basis over a field.\n\
                         \Small Buchberger's examples No 1, No2.  \
                         \gxBasis_test  applied as earlier.\n" .
              finsep . shows (map fst [gbasBu1,gbasBu2]) 

  gbasCst' =
    showString 
      "\n\nGroebner basis over a field K.\n\
      \The consistency conditions for the three generic quadratic \
      \equations\nover K:\n\
      \fs = [x^2*a + x*b + c, x^2*d + x*e + f, x^2*g + x*h + l].\n\
      \Find  gs = GroebnerBasis(fs)  for the variables \
      \[x,l,h,g,f,e,d,c,b,a]\nand the  lex  pp ordering for  \
      \x > l >...> a.\ngs  provides certain conditions on the values of\
      \  a ... l for the\nconsistency of the system in extension of K. \
      \For example, each\nelement of  gs  constant in x,  must equal \
      \zero.\n" . 
    finsep . shows (fst gbasCst) 

  gbasCyclRoot' =
    showString "\n\nGroebner basis over a field K.  Cyclic roots.\n\
       \fs = [x1 + x2 + ... + xn, \n\
       \      x1*x2 + x2*x3 + ... + x(n-1)*xn + xn*x1,\n\
       \      ...\n\
       \      x1*x2..*x(n-1) + x2*x3..*xn +...+ xn*x1..*x(n-2),\n\
       \      x1*x2..*xn - 1\n\
       \     ]\n\
       \For  n = 2,3,5,  it appears that Ideal(fs) has zero dimension\n\
       \(this is visible from [lpp g| g <- Groebner basis]).\n\
       \For the test, we take  n = 4:\n" . 
    finsep . shows (fst gbasCyclRoot) 

  gbasMoe12' =
         showString (concat
             ["\n\nGroebner basis over a Euclidean ring Z = Integer.\n",
              header "",  "The two examples from Moeller's papers.\n\
              \gxBasis fs, gxBasis fs'  for\n\
              \fs  = [2*y*x^2 -17*y, 5*y^2*x -3*x],\n\
              \fs' = [7*x^2*y - 3*x, 4*x*y^2 - x*y, 3*y^3]\n\
              \- in Z[y,x], degLex pp ordering.\n\
              \The extended  gxBasis_test  is also applied.\n"
             ]) .
         finsep . shows (map fst [gbasMoe1, gbasMoe2]) 

  gbasOverP' =
    showString (concat 
     ["\n\nGroebner basis over a Euclidean ring X = K[x],  K a field\n",
      header "",
      "fs = [x^2*y^2 - z^2, x*y^2*z - x*y*z, x^3*y*z - x*z^2]\n\
      \reads to K[x,y,z] and to X[y,z].  The pp ordering is set so \
      \that\nx^k < y,z  for any k > 0.\n\
      \Compute the Groebner bases  gs, gs'  in these rings, and check\n\
      \gs == (map fromOverX gs'),  where\n\
      \fromOverX: X[y,z] -> K[x,y,z]  is the canonical isomorphism.\n"
     ]) .
    finsep . shows (fst gbasOverP)

  syzAl' = 
    showString (concat 
        ["\n\nGroebner basis in the module P^2  over P = K[a,b,c,d],\n",
         header "",
         "K a field,  and syzygies for a list of elements of P^2.\n\
         \Three small vectors in  P^2  are taken to  fs,\n\
         \set the TOP e-comparison  for  P^2  represented by  VecPol.\n\
         \Then,  fst (gxBasisM _ fs)  has to be certain [g1,g2,g3,g4]\n\
         \- which is checked.\n\
         \The syzygy generators  rels = syzygyGensM _ _ fs\n\
         \has to be a certain singleton - which is checked.\n"
        ]) . 
    finsep . shows (tuple51 al) 

  syzCocoa' = 
     showString (concat 
        ["\n\nComparing Syzygies from CoCoA and DoCon.\n\
         \Example from the CoCoA manual of 1990.\n",  header "",
         "In  fs = [f1..f7]  fi <- P = K[x,y,z,w],  fs  occurs a \
         \Groebner basis.\n\
         \rels = syzygyGens _ fs  are the syzygies from DoCon,\n\
         \- a list of vectors from P^7.\n\
         \relsCo  are the syzygy generators computed by CoCoA.\n\
         \The submodule equality for  rels, relsCo  is verified.\n\
         \The TOP e-comparison is set on P^7 induced by the weights \
         \[lpp f| f <- fs].\nWith this,  rels  also becomes a Groebner\
         \ basis in P^7.\nHence, reducing  rels  mutually and finding \
         \the Groebner basis  relsCoG\nfor  relsCo,  we obtain \
         \relsReduced  and  relsCoG.\nIt is tested that these two \
         \coincide as sets.\n"
        ]) .
     finsep . shows (tuple51 cocoa) 

  cyclicInt5' = 
    showString (concat 
        ["\n\nArithmetic of Cyclic Integer ring\nmodelled via Groebner\
         \ basis over Integer.\n",  header "",
         "The cyclic integers are the elements of   CI = Z[x]/(g),\n\
         \        g = x^p' + x^(p'-1) +..+ 1,   p'= p-1,  p prime.\n\n\
         \It is known that  g = (x^p-1)/(x-1)   is irreducible.\n\
         \With DoCon, we can simply put  CI = ResidueI $ UPol Integer. \
         \ And\nthis relies on the Groebner basis technique over an \ 
         \Euclidean ring\nInteger.  Build Z[x]/(g)  and test the \
         \properties\n(IsField,No), (HasZeroDiv,No).  Then, take, \
         \for example,\nsome f, g and test the division and algebraic \
         \norm.\n\
         \Here, we put  p = 5,  f = 38*x^3 + 62*x^2 + 56*x + 29,\n\
         \                      g =  3*x^3 +  4*x^2 +  7*x +  1.\n\
         \  f  must be a multiple of  g,\n\
         \  norm(f) must be a multiple of norm(g).\n"
        ]) . 
    finsep . shows (tuple31 cyclicInt5) 

  cubeext' = 
    showString (concat 
      ["\n\ncubicExt a b dK   builds the radical extension tower\n\
       \                          k -- k(d) -- E = k(d)(u,v,r)\n",  
       header "",
       "for the given field  k,  where E is generated by the roots of\n\
       \irreducible   f = t^3 + a*t + b,   a,b from k, a /= 0.\n\
       \d,r,u,v  stand for the (square) root of discriminant,\n\
       \         root of -3,  Cardano cubic radicals.\n\
       \B = k(d)[u,v,r]  is built,  and  E = B/Ideal(eqs),\n\
       \where  eqs  are certain quadratic and cubic relations for \
       \u,v,r  over k(d).\n\
       \B/Ideal(eqs)  requires GroebnerBasis(eqs) to evaluate over \
       \k(d).\n\
       \The Cardano values x,y,z  for the roots of  f  are formed in \
       \E.\nAnd  (domainE, [x,y,z], kToE)  is returned.\n\
       \For this particular example,  cubicExt (1:/1) (-1:/1) dQ   \
       \builds the\nextension of k = Q = Rational with t^3 - t + 1.\n\
       \Then, the Viete relations are tested for  x, y, z.\n\
       \And certain interesting quadratic expression for  y  via  x  \
       \over k(d)\nis found - it must exist according to the extension \
       \dimension\nconsiderations.\n"
      ]) .
    finsep . shows (tuple41 t_cubeext_) 

  sphGeo' =
    showString (concat
       ["\n\nArithmetic of the field Q(S)  of rational functions on the\
        \ sphere\nS:  x^2 + y^2 + z^2 = 1.\n",  header "",
        "Build  K = F[z]/(p),  with  p = x^2 + y^2 + z^2 - 1,\n\
        \F = Fraction Z[x,y].\nIn particular,  1/(1+z)  must equal \
        \ (1-z)/(x^2+y^2) in K.\nAnd this is tested.\n\
        \The arithmetics in  F  requires gcd cancellation in Z[x,y],  \
        \and\nF[z]/(p)  requires the Euclidean structure for F[z].\n"
       ]) .
    finsep . shows (tuple31 t_sphGeo_) 

  charKostka' = 
    showString (concat 
       ["\n\nSymmetric function transformation.\n",  header 
        "Character matrix  C  for the permutation group  S(w),\n\
        \Kostka matrix  K(w),   w  the weight parameter.\n",  header "",
        "For  C,  there are checked the orthogonality of rows, control \
        \sum.\n\
        \For  K,  there are checked the triangularity, control sum,\n\
        \1 on diagonal, inverse(K).\nThis repeats for  w <- [2 .. 8].\n"
       ]) .
    finsep . shows charKostkaTest 

  discrSym' = 
    showString "\n\nSymmetric function transformation.\n\
           \Find  d = discriminant [x1..xn] = product [(xi-xj)^2 ...]\n\
           \as polynomial over Q = Rational,\nconvert it to  dsym = \
           \toSymPol .. dsym :: SymPol Q,\n\
           \decompose  dsym  to elementary symmetrics:  \
           \(to_e_pol mode.. dsym).\n\
           \There are checked the results of these two conversions\n\
           \- for  n = 3, mode = \"mn\", \"m\", \n\
           \       n = 4, mode = \"mn\". \n" .
    finsep . shows discrSymTest 

  symMonToE' =
    showString 
        "\n\nSymmetric function transformation.\n\
        \Decomposing a symmetric monomial  \
        \m[jjj] = symmetricOrbit( x^j*y^j*z^j )\n\
        \into polynomial  h <- Q[e1,e2..]  in elementary symmetrics \
        \over Rational.\n\
        \ContorlSum(h) is checked for n = 3, mode = \"mn\", \"m\", \n\
        \                             n = 4, mode = \"mn\".        \n" .
    finsep . shows symMonToETest 

  upolInterp1' = 
    showString (concat 
      ["\n\nUnivariate Polynomial Interpolation.  Small direct test.\n",
       header "",
       "For a prime  p,  K = Z/(p),  f <- K[t],  deg f < p,\n\
       \take the values of f in  (deg f)+1  points, interpolate by \
       \these values\nand compare the result to  f.  Here we put\n\
       \q = 11,  f = 1, 2*t+3, (2*t^2 +3*t +4)^3,  t^10 +t^9 +t.\n"
      ]) .
    finsep . shows (fst interp)

  upolInterp2' = 
    showString (concat
      ["\n\nUnivariate Polynomial Interpolation.\n\
       \Finding Determinant over Polynomials via interpolation.\n",
       header "",
       "The idea is that for a  finite field K,  P = K[t],  matrix M \
       \over P,\ndet M  costs much less when it is computed via \
       \interpolation\n(instead of Gauss method with repeated remainder\
       \ division).\n\
       \deg det(M)  is estimated by degBound found via deg M(i,j),\n\
       \degBound+1  values  det(i)  of  det(M(i)) compute over K,  and \
       \the\npolynomial  det(M)  is interpolated from  det(i).\n\
       \If  degBound >= card K  then K  is extended to appropriate K' \
       \- certain\nprime polynomial to be found!  Everything is found \
       \over  K',\nthe result projected to  K[t].\n\
       \We apply this method to  det M,  M = resultantMatrix f g,\n   \
       \                                             f, g <- K[t][x],\n\
       \det(M)  computed by interpolation is compared to  det(M) \
       \ computed via\nthe Gauss method\n\
       \(in  T_detinterp.hs  you can also see how to run these \
       \methods\nseparately to compare the cost).\nHere we put\n\
       \K      = Z/(11)\n\
       \(f, g) = ((t+1)*x^2 + t^2*x + 2,      t*x^2 + 3*x^3 + t),\n\
       \         ((t^2+1)*x^4 + 3*x^3 + t^2*x^2 + t^3 +t + 2,\n\
       \                                  x^4 - (t+1)*x^3 + t^2*x)\n\
       \- the second pair causes the extension of K.\n"
     ]) .
    finsep . shows (snd interp) 

  factor1overPrimeFin' =
    showString (concat 
     ["\n\nFactorization in K[t],  K = Z/(p) a prime finite field.\n",
      header "",
      "factor (t^10 +t^7 +t^5 +t^3 +t^2 + 2*t + 2)   over Z/(5),\n\
      \factor (t^8+t^6+10t^4+ 10t^3+ 8t^2 + 2t + 8)  over Z/(13).\n\
      \It is also known that  factor (t^(p^d) - t)\n\
      \lists all the irreducible polynomials  f  over Z/(p), with  d\n\
      \a multiple of  deg f,  lc f = 1 \
      \- test this for (p = 2, d <- [1..6]),\n(p = 3, d <- [1 .. 4]).\n"
     ]) . 
    finsep . shows factor1overPrimeFin 

  factor1overGenFin' = 
    showString (concat
      ["\n\nFactorization in  K1[x],  K1  a generic finite extension \
       \of\na prime field K = Z/(p),\n",  header "",
       "K1 = K[t]/(g)  for the chosen irreducible  g  over K.\n\
       \Here we take  p = 5,  g = t^3 - t - 2    and test factorization\
       \ for\nthe polynomials  f1,f2,f3.\n\
       \f1 = t^10 + t^7 + t^5 + t^3 + t^2 + 2*t + 2   over K1,\n\
       \ starts to factor as f1 over K (from the previous test),\n\
       \ only the factor  x^3-x+3  splits further to the linear \
       \factors over K1.\n\
       \f2 = x^10 + 2*t*x^5 + t^2 + 2\n\
       \  factors to a certain [(h,5)], because  f = sum [ak*x^(5*k)]  \
       \and\neach\nak(t)  is a 5-th degree in K1.\n\
       \f3  is a certain large polynomial (see T_pfactor.hs).\n"
      ]) . 
    finsep . shows factor1overGenericFin 

  factor2overPrimeFin' =
    showString (concat
      ["\n\nFactorization in  K[x,y],  K = Z/(p) a prime field.\n",
       header "",
       "First, take different irreducible f,g, small in total deg \
       \and test\n[factor (f^i*g^j) |  0 < i, j < bound].\n\
       \Here, we take  f = x^3 + y*(x + 1),  \
                      \g = x^3 + y*(y*x^2 + 2),\n\
       \               (i,j) <- [(0,1),(1,0),(1,1),(1,2),(2,1)].\n\
       \Second test.\n\
       \Take a prime  b <- [0..p-1],  p <- K[t],  n = 3,4, ...\n\n\
       \gs = [p^(n-1)*x^(n-1) + (a+b)*y*x^(n-2) + (a-b)*p^2*x +a |\n\
       \      a <- [1..(q-1)] ],\n\
       \irreds = [x^n + p*g | g <- gs]\n       \
       \    - all of them irreducible by the Eisenstein condition,\n\
       \fs = [g*h | g,h <- irreds]\n      \
       \  - fi have  deg_x fi = deg_y fi = 2*n  and have to factor \
       \to the\n  above pairs of the elements of  irreds.\n\
       \Here we take   b = 1,  p = y + b,   n = 3, 4, 5\n\
       \and first 2 of the  fs  factorizations.\n\
       \W A I T,\n(on a 2 GHz computer this takes about 3 seconds):\n"
      ]) . 
    finsep . shows factor2overPrimeFin





{- Statistics  -----------------------------------------------------


Note: 
we have to take in account that, in rare cases, the example set, and
parameters, may change from version to version.

---------------------------------------------------------
docon-2.09-pre-July-21-2005,   ghc-6.4.1-pre-July-10-2005
docon compiled with -0,  tests compiled with -Onot.

./a.out  for Main  on  512 Mb memory takes  36 seconds.

--------------------------------------------------------------------
-}